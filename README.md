Оригинал задания: <https://krasnoslabodtsev.notion.site/Java-8cb66b18acc844dfbc0958c6f82e400c>

**Структура таблиц БД**

| Key type | Column | Type | Unique | Comment |
| --- | --- | --- | --- | --- |
| Table: USER |  |  |  |  |
| PK | ID | BIGINT | True |  |
|  | NAME | VARCHAR(500) |  |  |
|  | DATE_OF_BIRTH |  |  | Format: 01.05.1993 |
|  | PASSWORD | VARCHAR(500) |  | Min length: 8, max 500 |
| Table: ACCOUNT |  |  |  |  |
| PK | ID | BIGINT | True |  |
| FK | USER_ID | BIGINT | True | Link to USER.ID |
|  | BALANCE | DECIMAL |  | рубли + копейки: в коде – BigDecimal |
| Table: EMAIL_DATA |  |  |  |  |
| PK | ID | BIGINT | True |  |
| FK | USER_ID | BIGINT |  | Link to USER.ID |
|  | EMAIL | VARCHAR(200) | True |  |
| Table: PHONE_DATA |  |  |  |  |
| PK | ID | BIGINT | True |  |
| FK | USER_ID | BIGINT |  | Link to USER.ID |
|  | PHONE | VARCHAR(13) | True | format: 79207865432 |


**Общие требование к системе:**

1. 3 слоя – API, service, DAO
2. Будем считать, что в системе только обычные пользователи (не админы и т.д).
3. Будем считать, что пользователи создаются миграциями (не будем усложнять). Просто считаем, что для обычных пользователей нет операции создания. Для тестов создать напрямую в DAO.
4. У пользователя может быть более одного PHONE_DATA (должен быть как минимум 1).
5. У пользователя может быть более одного EMAIL_DATA (должен быть как минимум 1).
6. У пользователя должен быть быть строго один ACCOUNT.
7. Начальный BALANCE в ACCOUNT указывается при создании пользователя.
8. BALANCE в ACCOUNT не может уходить в минус ни при каких операциях.
9. Валидация входных API данных.

**Обязательные фичи:**

1. CREATE (только для определенных внутри пользователя данных), UPDATE операции для пользователя. Пользователь может менять только собственные данные:
2. может удалить/сменить/добавить email если он не занят другим пользователям
3. может удалить/сменить/добавить phone если он не занят другим пользователям
4. остальное менять не может
5. Реализовать READ операцию для пользователей. Сделать «поиск пользователей» (искать может любой любого) с фильтрацией по полям ниже и пагинацией (size, page/offset):
6. Если передана «dateOfBirth», то фильтр записей, где «date_of_birth» больше чем переданный в запросе.
7. Если передан «phone», то фильтр по 100% сходству.
8. Если передан «name», то фильтр по like форматом ‘{text-from-request-param}%’
9. Если передан «email», то фильтр по 100% сходству.
10. Добавить JWT token (необходимый Claim только USER_ID), механизм получения токена на ваше усмотрение. Имплементировать максимально просто, не стоит усложнять. Аутентификация может быть по email+password, либо по phone+password.
11. Раз в 30 секунд BALANCE каждого клиента увеличиваются на 10% но не более 207% от начального депозита.
Например:Было: 100, стало: 110.Было: 110, стало:121.…Окончательное значение: 194.87*
12. Сделать функционал трансфер денег от одного пользователя к другому.
Вход: USER_ID (transfer from) – берем у авторизованного из Claim токена, USER_ID (transfer to) из запроса, VALUE (сумма перевода) из запроса.
То есть у того, кто переводит мы списываем эту сумму, у того, кому переводим – добавляем эту сумму.Считать эту операцию «банковской» (высоко-значимой), сделать ее со всеми нужными валидациями (надо подумать какими) и потоко-защищенной.

13. Создание нового пользователя должно происходить с помощью принятия сообщения из RabbitMQ

**Необязательные фичи (но которые очень хотелось бы видеть, хотя бы в минимальном исполнении):**

1. Добавить swagger (минимальную конфигурацию).
2. Добавить не бездумное (значимое) логгирование.
3. Добавить корректное кэширование (например на API и на DAO слой). Имплементация на ваше усмотрение.

**Тестирование:**

Покрытие unit тестами. Не надо покрывать тестами весь код. Нужно сделать тесты на покрытие функционала трансфера денег через MockMvc и операцию создание пользователя  покрыть через testcontainers

